diff --git a/solr/core/src/java/org/apache/solr/core/StackTracePritner.java b/solr/core/src/java/org/apache/solr/core/StackTracePritner.java
new file mode 100644
index 00000000000..8c1fa6bcdb5
--- /dev/null
+++ b/solr/core/src/java/org/apache/solr/core/StackTracePritner.java
@@ -0,0 +1,20 @@
+package org.apache.solr.core;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.lang.invoke.MethodHandles;
+
+public class StackTracePritner {
+
+    private static final  org.slf4j.Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
+
+    public static void logStackTrace(String prefix)
+    {
+    StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();
+    String outLog="";
+    for (StackTraceElement stackTraceElement : stackTraceElements) {
+      outLog=outLog+("    at " + stackTraceElement);
+    }
+    log.info("[MNP] {} Thread.currentThread().getStackTrace():  {}",prefix,outLog);
+}
+    
+}
diff --git a/solr/core/src/java/org/apache/solr/core/backup/BackupManager.java b/solr/core/src/java/org/apache/solr/core/backup/BackupManager.java
index 9a5d2a928da..8f36633b5f6 100644
--- a/solr/core/src/java/org/apache/solr/core/backup/BackupManager.java
+++ b/solr/core/src/java/org/apache/solr/core/backup/BackupManager.java
@@ -94,6 +94,7 @@ public class BackupManager {
     Objects.requireNonNull(backupLoc);
     Objects.requireNonNull(backupId);
 
+    log.info("[MNP] called readBackupProperties backupLoc={} backupId={}",backupLoc,backupId);
     // Backup location
     URI backupPath = repository.resolve(backupLoc, backupId);
     if (!repository.exists(backupPath)) {
@@ -117,6 +118,7 @@ public class BackupManager {
    * @throws IOException in case of I/O error
    */
   public void writeBackupProperties(URI backupLoc, String backupId, Properties props) throws IOException {
+    log.info("[MNP] called writeBackupProperties backupLoc={} backupId={} props={}",backupLoc,backupId,props.toString());
     URI dest = repository.resolve(backupLoc, backupId, BACKUP_PROPS_FILE);
     try (Writer propsWriter = new OutputStreamWriter(repository.createOutput(dest), StandardCharsets.UTF_8)) {
       props.store(propsWriter, "Backup properties file");
@@ -134,13 +136,16 @@ public class BackupManager {
    */
   public DocCollection readCollectionState(URI backupLoc, String backupId, String collectionName) throws IOException {
     Objects.requireNonNull(collectionName);
-
+    log.info("[MNP] called readCollectionState backupLoc={} backupId={} collectionName={}",backupLoc,backupId,collectionName); 
     URI zkStateDir = repository.resolve(backupLoc, backupId, ZK_STATE_DIR);
     try (IndexInput is = repository.openInput(zkStateDir, COLLECTION_PROPS_FILE, IOContext.DEFAULT)) {
       byte[] arr = new byte[(int) is.length()]; // probably ok since the json file should be small.
       is.readBytes(arr, 0, (int) is.length());
       ClusterState c_state = ClusterState.load(-1, arr, Collections.emptySet());
-      return c_state.getCollection(collectionName);
+
+      DocCollection outColl= c_state.getCollection(collectionName);
+      log.info("[MNP] returning from  readCollectionState backupLoc={} backupId={}, collectionName={} collectionState={}",backupLoc,backupId,collectionName,Utils.toJSON(Collections.singletonMap(collectionName, outColl))); 
+      return outColl;
     }
   }
 
@@ -156,6 +161,8 @@ public class BackupManager {
   public void writeCollectionState(URI backupLoc, String backupId, String collectionName,
                                    DocCollection collectionState) throws IOException {
     URI dest = repository.resolve(backupLoc, backupId, ZK_STATE_DIR, COLLECTION_PROPS_FILE);
+    
+    log.info("[MNP] called writeCollectionState backupLoc={} backupId={}, collectionName={}, collectionState={}",backupLoc,backupId,collectionName,Utils.toJSON(Collections.singletonMap(collectionName, collectionState))); 
     try (OutputStream collectionStateOs = repository.createOutput(dest)) {
       collectionStateOs.write(Utils.toJSON(Collections.singletonMap(collectionName, collectionState)));
     }
@@ -172,6 +179,7 @@ public class BackupManager {
    */
   public void uploadConfigDir(URI backupLoc, String backupId, String sourceConfigName, String targetConfigName)
       throws IOException {
+    log.info("[MNP] uploadConfigDir backupLoc={} backupId={},sourceConfigName={}, targetConfigName={}",backupLoc,backupId,sourceConfigName,targetConfigName);
     URI source = repository.resolve(backupLoc, backupId, ZK_STATE_DIR, CONFIG_STATE_DIR, sourceConfigName);
     String zkPath = ZkConfigManager.CONFIGS_ZKNODE + "/" + targetConfigName;
     uploadToZk(zkStateReader.getZkClient(), source, zkPath);
@@ -191,10 +199,13 @@ public class BackupManager {
     repository.createDirectory(repository.resolve(backupLoc, backupId, ZK_STATE_DIR, CONFIG_STATE_DIR));
     repository.createDirectory(dest);
 
+    log.info("[MNP] uploadConfigDir backupLoc={} backupId={},configName={}",backupLoc,backupId,configName);
+    
     downloadFromZK(zkStateReader.getZkClient(), ZkConfigManager.CONFIGS_ZKNODE + "/" + configName, dest);
   }
 
   public void uploadCollectionProperties(URI backupLoc, String backupId, String collectionName) throws IOException {
+    log.info("[MNP] uploadCollectionProperties backupLoc={} backupId={},collectionName={}",backupLoc,backupId,collectionName);
     URI sourceDir = repository.resolve(backupLoc, backupId, ZK_STATE_DIR);
     URI source = repository.resolve(sourceDir, ZkStateReader.COLLECTION_PROPS_ZKNODE);
     if (!repository.exists(source)) {
@@ -214,6 +225,8 @@ public class BackupManager {
   }
 
   public void downloadCollectionProperties(URI backupLoc, String backupId, String collectionName) throws IOException {
+    
+    log.info("[MNP] downloadCollectionProperties backupLoc={} backupId={},collectionName={}",backupLoc,backupId,collectionName);
     URI dest = repository.resolve(backupLoc, backupId, ZK_STATE_DIR, ZkStateReader.COLLECTION_PROPS_ZKNODE);
     String zkPath = ZkStateReader.COLLECTIONS_ZKNODE + '/' + collectionName + '/' + ZkStateReader.COLLECTION_PROPS_ZKNODE;
 
@@ -236,6 +249,8 @@ public class BackupManager {
 
   private void downloadFromZK(SolrZkClient zkClient, String zkPath, URI dir) throws IOException {
     try {
+
+      log.info("[MNP] downloadCollectionProperties zkClient={} zkPath={},dir={}",zkClient.toString(),zkPath,dir.toURL());
       if (!repository.exists(dir)) {
         repository.createDirectory(dir);
       }
@@ -259,6 +274,9 @@ public class BackupManager {
   }
 
   private void uploadToZk(SolrZkClient zkClient, URI sourceDir, String destZkPath) throws IOException {
+
+    log.info("[MNP] downloadCollectionProperties zkClient={} sourceDir={},destZkPath={}",zkClient.toString(),sourceDir.toURL(),destZkPath);
+
     Preconditions.checkArgument(repository.exists(sourceDir), "Path {} does not exist", sourceDir);
     Preconditions.checkArgument(repository.getPathType(sourceDir) == PathType.DIRECTORY,
         "Path {} is not a directory", sourceDir);
diff --git a/solr/core/src/java/org/apache/solr/core/backup/repository/HdfsBackupRepository.java b/solr/core/src/java/org/apache/solr/core/backup/repository/HdfsBackupRepository.java
index 6c0b04c3f72..d65cf0e15b2 100644
--- a/solr/core/src/java/org/apache/solr/core/backup/repository/HdfsBackupRepository.java
+++ b/solr/core/src/java/org/apache/solr/core/backup/repository/HdfsBackupRepository.java
@@ -22,6 +22,7 @@ import java.io.OutputStream;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.util.Objects;
+import java.lang.invoke.MethodHandles;
 
 import com.google.common.base.Preconditions;
 import org.apache.hadoop.conf.Configuration;
@@ -41,7 +42,15 @@ import org.apache.solr.core.HdfsDirectoryFactory;
 import org.apache.solr.store.hdfs.HdfsDirectory;
 import org.apache.solr.store.hdfs.HdfsDirectory.HdfsIndexInput;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
 public class HdfsBackupRepository implements BackupRepository {
+  
+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
+
+
   private static final String HDFS_UMASK_MODE_PARAM = "solr.hdfs.permissions.umask-mode";
   private static final String HDFS_COPY_BUFFER_SIZE_PARAM = "solr.hdfs.buffer.size";
 
@@ -63,6 +72,7 @@ public class HdfsBackupRepository implements BackupRepository {
       if (this.copyBufferSize <= 0) {
         throw new IllegalArgumentException("Value of " + HDFS_COPY_BUFFER_SIZE_PARAM + " must be > 0");
       }
+    
     }
 
     String hdfsSolrHome = (String) Objects.requireNonNull(args.get(HdfsDirectoryFactory.HDFS_HOME),
@@ -72,7 +82,7 @@ public class HdfsBackupRepository implements BackupRepository {
       baseHdfsPath = path;
       path = path.getParent();
     }
-
+    
     // We don't really need this factory instance. But we want to initialize it here to
     // make sure that all HDFS related initialization is at one place (and not duplicated here).
     factory = new HdfsDirectoryFactory();
@@ -90,13 +100,20 @@ public class HdfsBackupRepository implements BackupRepository {
     } catch (IOException e) {
       throw new SolrException(ErrorCode.SERVER_ERROR, e);
     }
+    log.info("[MNP] called HdfsBackupRepository.init, HDFS_COPY_BUFFER_SIZE_PARAM:{}, hdfsSolrHome:{}, HDFS_UMASK_MODE_PARAM:{} ",HDFS_COPY_BUFFER_SIZE_PARAM,hdfsSolrHome,HDFS_UMASK_MODE_PARAM);
   }
 
+
   public void close() throws IOException {
+
+    log.info("[MNP] called HdfsBackupRepository.close");
+  
     if (this.fileSystem != null) {
+      log.info("[MNP] called HdfsBackupRepository.close, fileSystem is not null");
       this.fileSystem.close();
     }
     if (this.factory != null) {
+      log.info("[MNP] called HdfsBackupRepository.close, factory is not null");
       this.factory.close();
     }
   }
@@ -138,11 +155,15 @@ public class HdfsBackupRepository implements BackupRepository {
 
   @Override
   public boolean exists(URI path) throws IOException {
-    return this.fileSystem.exists(new Path(path));
+
+    boolean output=this.fileSystem.exists(new Path(path));
+    log.info("[MNP] called HdfsBackupRepository.exists, path:{}, result:{}",path.toURL(),output);
+    return output;
   }
 
   @Override
   public PathType getPathType(URI path) throws IOException {
+    log.info("[MNP] called HdfsBackupRepository.getPathType, path:{} ",path.toURL());
     return this.fileSystem.isDirectory(new Path(path)) ? PathType.DIRECTORY : PathType.FILE;
   }
 
@@ -150,32 +171,40 @@ public class HdfsBackupRepository implements BackupRepository {
   public String[] listAll(URI path) throws IOException {
     FileStatus[] status = this.fileSystem.listStatus(new Path(path));
     String[] result = new String[status.length];
+    
+    String outLog="";
     for (int i = 0; i < status.length; i++) {
       result[i] = status[i].getPath().getName();
+      outLog=outLog+" "+result[i];
     }
+    log.info("[MNP] called HdfsBackupRepository.getPathType, path:{}, result:{} ",path.toURL(),outLog);
     return result;
   }
 
   @Override
   public IndexInput openInput(URI dirPath, String fileName, IOContext ctx) throws IOException {
     Path p = new Path(new Path(dirPath), fileName);
+    log.info("[MNP] called HdfsBackupRepository.openInput, dirPath:{}, fileName:{}, ctx:{} ",dirPath.toURL(),fileName,"???");
     return new HdfsIndexInput(fileName, this.fileSystem, p, HdfsDirectory.DEFAULT_BUFFER_SIZE);
   }
 
   @Override
   public OutputStream createOutput(URI path) throws IOException {
+    log.info("[MNP] called HdfsBackupRepository.createOutput, path:{}",path.toURL());
     return this.fileSystem.create(new Path(path));
   }
 
   @Override
   public void createDirectory(URI path) throws IOException {
     if (!this.fileSystem.mkdirs(new Path(path))) {
+      log.info("[MNP] called HdfsBackupRepository.createDirectory, path:{}",path.toURL());
       throw new IOException("Unable to create a directory at following location " + path);
     }
   }
 
   @Override
   public void deleteDirectory(URI path) throws IOException {
+    log.info("[MNP] called HdfsBackupRepository.deleteDirectory, path:{}",path.toURL());
     if (!this.fileSystem.delete(new Path(path), true)) {
       throw new IOException("Unable to delete a directory at following location " + path);
     }
@@ -183,6 +212,7 @@ public class HdfsBackupRepository implements BackupRepository {
 
   @Override
   public void copyFileFrom(Directory sourceDir, String fileName, URI dest) throws IOException {
+    log.info("[MNP] called HdfsBackupRepository.copyFileFrom, sourceDir:{}, fileName:{}, dest:{}",sourceDir, fileName,dest.toURL());
     try (HdfsDirectory dir = new HdfsDirectory(new Path(dest), NoLockFactory.INSTANCE,
         hdfsConfig, copyBufferSize)) {
       dir.copyFrom(sourceDir, fileName, fileName, DirectoryFactory.IOCONTEXT_NO_CACHE);
@@ -191,6 +221,7 @@ public class HdfsBackupRepository implements BackupRepository {
 
   @Override
   public void copyFileTo(URI sourceRepo, String fileName, Directory dest) throws IOException {
+    log.info("[MNP] called HdfsBackupRepository.copyFileTo, sourceRepo:{}, fileName:{}, dest:{}",sourceRepo.toURL(),fileName,dest);
     try (HdfsDirectory dir = new HdfsDirectory(new Path(sourceRepo), NoLockFactory.INSTANCE,
         hdfsConfig, copyBufferSize)) {
       dest.copyFrom(dir, fileName, fileName, DirectoryFactory.IOCONTEXT_NO_CACHE);
diff --git a/solr/core/src/java/org/apache/solr/core/backup/repository/LocalFileSystemRepository.java b/solr/core/src/java/org/apache/solr/core/backup/repository/LocalFileSystemRepository.java
index 01810f6f8a8..6becc6611c6 100644
--- a/solr/core/src/java/org/apache/solr/core/backup/repository/LocalFileSystemRepository.java
+++ b/solr/core/src/java/org/apache/solr/core/backup/repository/LocalFileSystemRepository.java
@@ -17,8 +17,11 @@
 
 package org.apache.solr.core.backup.repository;
 
+import java.lang.invoke.MethodHandles;
+
 import java.io.IOException;
 import java.io.OutputStream;
+import java.net.MalformedURLException;
 import java.net.URI;
 import java.net.URISyntaxException;
 import java.nio.file.FileVisitResult;
@@ -40,6 +43,10 @@ import org.apache.solr.core.DirectoryFactory;
 
 import com.google.common.base.Preconditions;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
 /**
  * A concrete implementation of {@linkplain BackupRepository} interface supporting backup/restore of Solr indexes to a
  * local file-system. (Note - This can even be used for a shared file-system if it is exposed via a local file-system
@@ -48,8 +55,13 @@ import com.google.common.base.Preconditions;
 public class LocalFileSystemRepository implements BackupRepository {
   private NamedList config = null;
 
+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
+
+
   @Override
   public void init(NamedList args) {
+
+    log.info("[MNP] called LocalFileSystemRepository.init, args:{}", args);
     this.config = args;
   }
 
@@ -84,17 +96,26 @@ public class LocalFileSystemRepository implements BackupRepository {
     for (int i = 0; i < pathComponents.length; i++) {
       result = result.resolve(pathComponents[i]);
     }
-
+    try{
+    log.info("[MNP] called LocalFileSystemRepository.resolve, baseUri:{}, pathComponents:{}, result:{}", baseUri.toURL(), pathComponents,result.toString() );
+    }
+    catch (MalformedURLException ex)
+    {
+      log.error(ex.getStackTrace().toString());
+    }
     return result.toUri();
   }
 
   @Override
   public void createDirectory(URI path) throws IOException {
+    log.info("[MNP] called LocalFileSystemRepository.createDirectory, path:{}",path.toURL());
     Files.createDirectory(Paths.get(path));
   }
 
   @Override
-  public void deleteDirectory(URI path) throws IOException {
+  public void deleteDirectory(URI path) throws IOException 
+  {
+  log.info("[MNP] called LocalFileSystemRepository.deleteDirectory, path:{}",path.toURL());
     Files.walkFileTree(Paths.get(path), new SimpleFileVisitor<Path>() {
       @Override
       public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
@@ -112,11 +133,15 @@ public class LocalFileSystemRepository implements BackupRepository {
 
   @Override
   public boolean exists(URI path) throws IOException {
-    return Files.exists(Paths.get(path));
+
+    boolean output=Files.exists(Paths.get(path));
+    log.info("[MNP] called LocalFileSystemRepository.exists, path:{}, result:{}",path.toURL(),output);
+    return output;
   }
 
   @Override
   public IndexInput openInput(URI dirPath, String fileName, IOContext ctx) throws IOException {
+    log.info("[MNP] called LocalFileSystemRepository.openInput, dirPath:{}, fileName:{}, IOContext:{}",dirPath.toURL(),fileName,"???");
     try (FSDirectory dir = new SimpleFSDirectory(Paths.get(dirPath), NoLockFactory.INSTANCE)) {
       return dir.openInput(fileName, ctx);
     }
@@ -124,23 +149,28 @@ public class LocalFileSystemRepository implements BackupRepository {
 
   @Override
   public OutputStream createOutput(URI path) throws IOException {
+    log.info("[MNP] called LocalFileSystemRepository.createOutput, path:{}",path.toURL());
     return Files.newOutputStream(Paths.get(path));
   }
 
   @Override
   public String[] listAll(URI dirPath) throws IOException {
     try (FSDirectory dir = new SimpleFSDirectory(Paths.get(dirPath), NoLockFactory.INSTANCE)) {
-      return dir.listAll();
+      String[] output = dir.listAll();
+      log.info("[MNP] called LocalFileSystemRepository.listAll, dirPath:{}, output:{}",dirPath.toURL(),output.toString() );
+      return output;
     }
   }
 
   @Override
   public PathType getPathType(URI path) throws IOException {
+    log.info("[MNP] called LocalFileSystemRepository.getPathType, path:{}",path.toURL());
     return Files.isDirectory(Paths.get(path)) ? PathType.DIRECTORY : PathType.FILE;
   }
 
   @Override
   public void copyFileFrom(Directory sourceDir, String fileName, URI dest) throws IOException {
+    log.info("[MNP] called LocalFileSystemRepository.copyFileFrom, sourceDir:{}, fileName:{}, dest:{}",sourceDir,fileName ,dest.toURL());
     try (FSDirectory dir = new SimpleFSDirectory(Paths.get(dest), NoLockFactory.INSTANCE)) {
       dir.copyFrom(sourceDir, fileName, fileName, DirectoryFactory.IOCONTEXT_NO_CACHE);
     }
@@ -148,6 +178,7 @@ public class LocalFileSystemRepository implements BackupRepository {
 
   @Override
   public void copyFileTo(URI sourceDir, String fileName, Directory dest) throws IOException {
+    log.info("[MNP] called LocalFileSystemRepository.copyFileTo, sourceDir:{}, fileName:{}, dest:{} ",sourceDir.toURL(), fileName, dest);
     try (FSDirectory dir = new SimpleFSDirectory(Paths.get(sourceDir), NoLockFactory.INSTANCE)) {
       dest.copyFrom(dir, fileName, fileName, DirectoryFactory.IOCONTEXT_NO_CACHE);
     }
diff --git a/solr/core/src/java/org/apache/solr/handler/admin/BackupCoreOp.java b/solr/core/src/java/org/apache/solr/handler/admin/BackupCoreOp.java
index 503eed03a3b..43cb330c4c2 100644
--- a/solr/core/src/java/org/apache/solr/handler/admin/BackupCoreOp.java
+++ b/solr/core/src/java/org/apache/solr/handler/admin/BackupCoreOp.java
@@ -29,19 +29,33 @@ import org.apache.solr.handler.SnapShooter;
 
 import static org.apache.solr.common.params.CommonParams.NAME;
 
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+import java.lang.invoke.MethodHandles;
 
 class BackupCoreOp implements CoreAdminHandler.CoreAdminOp {
+
+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());
+
+
   @Override
   public void execute(CoreAdminHandler.CallInfo it) throws Exception {
     final SolrParams params = it.req.getParams();
 
+ 
+
     String cname = params.required().get(CoreAdminParams.CORE);
     String name = params.required().get(NAME);
 
     String repoName = params.get(CoreAdminParams.BACKUP_REPOSITORY);
+    
+
+
     BackupRepository repository = it.handler.coreContainer.newBackupRepository(Optional.ofNullable(repoName));
 
     String location = repository.getBackupLocation(params.get(CoreAdminParams.BACKUP_LOCATION));
+    
+    log.info("[MNP] called BackupCoreOp.execute, it:{}, cname:{}, name:{}, repoName:{}, location:{}, commitName:{} ",it.toString(),cname,name, repoName,location,params.get(CoreAdminParams.COMMIT_NAME));
     if (location == null) {
       throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, "'location' is not specified as a query"
           + " parameter or as a default repository property");
